"""Pytest fixtures for snapshot testing.

These fixtures provide:
- Real git repositories
- Real database
- Real filesystem
- Mocked agent CLI (only external dependency)
- Standardized terminal size for consistent snapshots
- SVG snapshot extension for proper .svg file output

Note on pytest-xdist:
    Syrupy works with xdist for reading/writing snapshots. However, when running
    `--snapshot-update` with multiple workers, unused snapshot detection is disabled.
    To detect and delete unused snapshots, run with `-n 0` (sequential mode).

    Snapshot tests are grouped on the same xdist worker using `xdist_group` marker
    to minimize potential race conditions during snapshot writes.

Note on pytest-textual-snapshot compatibility:
    pytest-textual-snapshot 1.0.0 uses syrupy 4.x API (_file_extension class attr)
    which is incompatible with syrupy 5.x (file_extension property). We override
    the snap_compare fixture to use syrupy's built-in SVGImageSnapshotExtension.
"""

from __future__ import annotations

import re
from pathlib import Path, PurePath
from types import SimpleNamespace
from typing import TYPE_CHECKING, Any

import pytest
from syrupy.extensions.image import SVGImageSnapshotExtension

from kagan.acp.buffers import AgentBuffers
from kagan.app import KaganApp
from tests.helpers.git import init_git_repo_with_commit

if TYPE_CHECKING:
    from collections.abc import Awaitable, Callable, Iterable

    from _pytest.fixtures import FixtureRequest
    from syrupy.assertion import SnapshotAssertion
    from textual.app import App
    from textual.pilot import Pilot

    from kagan.config import AgentConfig


def _normalize_svg(svg: str) -> str:
    """Strip unique terminal IDs generated by rich.Console.export_svg().

    This ensures consistent snapshot comparisons regardless of terminal IDs.
    """
    return re.sub(r"\bterminal-\d+-([\w-]+)", r"terminal-\1", svg)


@pytest.fixture
def snap_compare(
    snapshot: SnapshotAssertion, request: FixtureRequest
) -> Callable[[str | PurePath | App[Any]], bool]:
    """Compare Textual app screenshots with stored SVG snapshots.

    This fixture overrides pytest-textual-snapshot's snap_compare to fix
    compatibility with syrupy 5.x. The original plugin uses the old syrupy 4.x
    API (_file_extension class attribute) which doesn't work with syrupy 5.x.

    Args:
        snapshot: Syrupy snapshot assertion fixture.
        request: Pytest fixture request.

    Returns:
        A comparison function that takes an app and returns True if matched.
    """
    # Use syrupy's built-in SVG extension for proper .svg file output
    snapshot = snapshot.use_extension(SVGImageSnapshotExtension)

    def compare(
        app: str | PurePath | App[Any],
        press: Iterable[str] = (),
        terminal_size: tuple[int, int] = (80, 24),
        run_before: Callable[[Pilot], Awaitable[None] | None] | None = None,
    ) -> bool:
        """Compare current app screenshot with stored snapshot.

        Args:
            app: An App instance or path to an App file.
            press: Key presses to simulate before taking screenshot.
            terminal_size: Terminal dimensions (width, height).
            run_before: Async callable to run before screenshot.

        Returns:
            True if screenshot matches snapshot, False otherwise.
        """
        from textual._doc import take_svg_screenshot
        from textual._import_app import import_app
        from textual.app import App as TextualApp

        if isinstance(app, TextualApp):
            app_instance = app
        else:
            path = Path(app)
            if path.is_absolute():
                app_path = str(path.resolve())
            else:
                node_path = request.node.path.parent
                app_path = str((node_path / app).resolve())
            app_instance = import_app(app_path)

        actual_screenshot = take_svg_screenshot(
            app=app_instance,
            press=press,
            terminal_size=terminal_size,
            run_before=run_before,
        )

        # Normalize SVG to strip unique terminal IDs for consistent comparison
        normalized_screenshot = _normalize_svg(actual_screenshot)

        return snapshot == normalized_screenshot

    return compare


# Standardized terminal size for consistent snapshots
SNAPSHOT_TERMINAL_COLS = 120
SNAPSHOT_TERMINAL_ROWS = 40


class MockAgent:
    """Mock ACP agent with controllable responses for snapshot testing.

    This mock simulates the Agent interface without spawning real processes.
    Responses are controlled via set_response() and set_tool_calls().
    """

    def __init__(
        self,
        project_root: Path,
        agent_config: AgentConfig,
        *,
        read_only: bool = False,
    ) -> None:
        self.project_root = project_root
        self._agent_config = agent_config
        self._read_only = read_only
        self._buffers = AgentBuffers()
        self._tool_calls: dict[str, Any] = {}
        self._thinking_text: str = ""
        self._ready = False
        self._stopped = False
        self._auto_approve = False
        self._model_override: str | None = None
        self._message_target: Any = None

        # Default response
        self._buffers.append_response("Done. <complete/>")

    def _stream_text(self) -> str:
        """Return response text stripped of signal tags for UI streaming."""
        import re

        text = self._buffers.get_response_text()
        if not text:
            return ""
        # Remove completion/review signal tags from streamed UI output
        text = re.sub(r"<complete\\s*/?>", "", text, flags=re.IGNORECASE)
        text = re.sub(r"<continue\\s*/?>", "", text, flags=re.IGNORECASE)
        text = re.sub(r"<blocked\\s+reason=\"[^\"]+\"\\s*/?>", "", text, flags=re.IGNORECASE)
        text = re.sub(r"<approve\\s*[^>]*?/?>", "", text, flags=re.IGNORECASE)
        text = re.sub(r"<reject\\s+reason=\"[^\"]+\"\\s*/?>", "", text, flags=re.IGNORECASE)
        return text.strip()

    def set_response(self, text: str) -> None:
        """Set the canned response text."""
        self._buffers.clear_response()
        self._buffers.append_response(text)

    def set_tool_calls(self, tool_calls: dict[str, Any]) -> None:
        """Set canned tool calls for the agent."""
        self._tool_calls = tool_calls

    def set_thinking_text(self, text: str) -> None:
        """Set canned thinking/reasoning text."""
        self._thinking_text = text

    def set_message_target(self, target: Any) -> None:
        """Set the message target for posting messages."""
        self._message_target = target

    def set_auto_approve(self, enabled: bool) -> None:
        """Set auto-approve mode."""
        self._auto_approve = enabled

    def set_model_override(self, model_id: str | None) -> None:
        """Set model override."""
        self._model_override = model_id

    def start(self, message_target: Any = None) -> None:
        """Start the mock agent and post AgentReady immediately."""
        self._message_target = message_target
        self._ready = True
        if self._message_target:
            from kagan.acp import messages

            self._message_target.post_message(messages.AgentReady())

    async def wait_ready(self, timeout: float = 30.0) -> None:
        """Wait for agent to be ready - immediately ready for mock."""
        self._ready = True
        if self._message_target:
            from kagan.acp import messages

            self._message_target.post_message(messages.AgentReady())

    async def send_prompt(self, prompt: str) -> str | None:
        """Send prompt and return stop reason."""
        import asyncio

        # Simulate agent completion with realistic delay
        if self._message_target:
            from kagan.acp import messages

            # Post thinking text first if configured
            if self._thinking_text:
                self._message_target.post_message(messages.Thinking("text", self._thinking_text))
                # Small delay to simulate thinking
                await asyncio.sleep(0.05)

            # Stream response text to UI
            stream_text = self._stream_text()
            if stream_text:
                self._message_target.post_message(messages.AgentUpdate("text", stream_text))
                # Delay to simulate streaming
                await asyncio.sleep(0.1)

            # Post tool calls if any
            for tool_call in self._tool_calls.values():
                self._message_target.post_message(messages.ToolCall(tool_call))
                # Delay to simulate tool execution
                await asyncio.sleep(0.05)

            # Yield to event loop to allow message processing
            await asyncio.sleep(0.05)

            # Post completion
            self._message_target.post_message(messages.AgentComplete())

            # Yield again to allow completion handling
            await asyncio.sleep(0.05)

        return "end_turn"

    def get_response_text(self) -> str:
        """Get the accumulated response text."""
        return self._buffers.get_response_text()

    def get_tool_calls(self) -> dict[str, Any]:
        """Get tool calls made by the agent."""
        return self._tool_calls

    @property
    def tool_calls(self) -> dict[str, Any]:
        """Property access to tool calls for compatibility."""
        return self._tool_calls

    def get_thinking_text(self) -> str:
        """Get thinking/reasoning text."""
        return self._thinking_text

    def clear_tool_calls(self) -> None:
        """Clear accumulated tool calls."""
        self._tool_calls.clear()

    async def stop(self) -> None:
        """Stop the mock agent."""
        self._stopped = True
        self._buffers.clear_all()

    async def cancel(self) -> bool:
        """Cancel current operation."""
        return True


class MockAgentFactory:
    """Factory for creating MockAgent instances with controllable behavior.

    Usage:
        factory = MockAgentFactory()
        factory.set_default_response("Plan created. <complete/>")
        factory.set_tool_calls({"tc-1": {...}})

        app = KaganApp(..., agent_factory=factory)

    Note:
        The __call__ return type is Any to satisfy AgentFactory protocol,
        since MockAgent is a test double that mimics Agent's interface
        without inheriting from it.
    """

    def __init__(self) -> None:
        self._default_response = "Done. <complete/>"
        self._default_tool_calls: dict[str, Any] = {}
        self._default_thinking = ""
        self._agents: list[MockAgent] = []

    def set_default_response(self, text: str) -> None:
        """Set default response for all created agents."""
        self._default_response = text

    def set_default_tool_calls(self, tool_calls: dict[str, Any]) -> None:
        """Set default tool calls for all created agents."""
        self._default_tool_calls = tool_calls

    def set_default_thinking(self, text: str) -> None:
        """Set default thinking text for all created agents."""
        self._default_thinking = text

    def get_last_agent(self) -> MockAgent | None:
        """Get the most recently created agent."""
        return self._agents[-1] if self._agents else None

    def get_all_agents(self) -> list[MockAgent]:
        """Get all created agents."""
        return list(self._agents)

    def __call__(
        self,
        project_root: Path,
        agent_config: AgentConfig,
        *,
        read_only: bool = False,
    ) -> Any:
        """Create a new MockAgent instance.

        Returns Any to satisfy AgentFactory protocol - MockAgent duck-types
        as Agent for testing purposes.
        """
        agent = MockAgent(project_root, agent_config, read_only=read_only)
        agent.set_response(self._default_response)
        agent.set_tool_calls(dict(self._default_tool_calls))
        agent.set_thinking_text(self._default_thinking)
        self._agents.append(agent)
        return agent


def _create_fake_tmux(sessions: dict[str, dict[str, Any]]) -> Callable[..., Any]:
    """Create a fake tmux function that tracks session state.

    This is reused from tests/conftest.py for consistency.
    """

    async def fake_run_tmux(*args: str) -> str:
        if not args:
            return ""
        command, args_list = args[0], list(args)
        if command == "new-session" and "-s" in args_list:
            idx = args_list.index("-s")
            name = args_list[idx + 1] if idx + 1 < len(args_list) else None
            if name:
                cwd = args_list[args_list.index("-c") + 1] if "-c" in args_list else ""
                # Extract environment variables from -e flags
                env: dict[str, str] = {}
                for i, val in enumerate(args_list):
                    if val == "-e" and i + 1 < len(args_list):
                        key, _, env_value = args_list[i + 1].partition("=")
                        env[key] = env_value
                sessions[name] = {"cwd": cwd, "env": env, "sent_keys": []}
        elif command == "kill-session" and "-t" in args_list:
            sessions.pop(args_list[args_list.index("-t") + 1], None)
        elif command == "send-keys" and "-t" in args_list:
            idx = args_list.index("-t")
            name = args_list[idx + 1]
            keys = args_list[idx + 2] if idx + 2 < len(args_list) else ""
            if name in sessions:
                sessions[name]["sent_keys"].append(keys)
        elif command == "list-sessions":
            return "\n".join(sorted(sessions.keys()))
        return ""

    return fake_run_tmux


@pytest.fixture
async def snapshot_project(tmp_path: Path) -> SimpleNamespace:
    """Create a real project with git repo and kagan config for snapshot testing.

    This fixture provides:
    - A real git repository with initial commit
    - A .kagan/config.toml file
    - Paths to DB and config for KaganApp initialization
    - Standardized for snapshot reproducibility
    """
    project = tmp_path / "snapshot_project"
    project.mkdir()

    # Initialize real git repo with commit
    await init_git_repo_with_commit(project)

    # Create .kagan directory with config
    kagan_dir = project / ".kagan"
    kagan_dir.mkdir()

    config_content = """# Kagan Snapshot Test Configuration
[general]
auto_start = false
auto_merge = false
default_base_branch = "main"
default_worker_agent = "claude"

[agents.claude]
identity = "claude.ai"
name = "Claude"
short_name = "claude"
run_command."*" = "echo mock-claude"
interactive_command."*" = "echo mock-claude-interactive"
active = true
"""
    (kagan_dir / "config.toml").write_text(config_content)

    return SimpleNamespace(
        root=project,
        db=str(kagan_dir / "state.db"),
        config=str(kagan_dir / "config.toml"),
        kagan_dir=kagan_dir,
    )


@pytest.fixture
def mock_acp_agent_factory() -> MockAgentFactory:
    """Factory that returns mock agents with controllable responses.

    Usage:
        def test_something(mock_acp_agent_factory, snapshot_project):
            # Configure responses before app creation
            mock_acp_agent_factory.set_default_response("Plan created...")
            mock_acp_agent_factory.set_default_tool_calls({...})

            app = KaganApp(
                db_path=snapshot_project.db,
                config_path=snapshot_project.config,
                agent_factory=mock_acp_agent_factory,
            )
    """
    return MockAgentFactory()


@pytest.fixture
async def snapshot_app(
    snapshot_project: SimpleNamespace,
    mock_acp_agent_factory: MockAgentFactory,
    monkeypatch: pytest.MonkeyPatch,
) -> KaganApp:
    """Create KaganApp with real DB, real git, but mocked agent factory.

    Terminal size is standardized to 120x40 for consistent snapshots.
    tmux is auto-mocked since CI may not have it.
    """
    # Mock tmux
    sessions: dict[str, dict[str, Any]] = {}
    fake_tmux = _create_fake_tmux(sessions)
    monkeypatch.setattr("kagan.sessions.tmux.run_tmux", fake_tmux)
    monkeypatch.setattr("kagan.sessions.manager.run_tmux", fake_tmux)

    app = KaganApp(
        db_path=snapshot_project.db,
        config_path=snapshot_project.config,
        lock_path=None,
        agent_factory=mock_acp_agent_factory,
    )

    return app


@pytest.fixture
def snapshot_terminal_size() -> tuple[int, int]:
    """Return standardized terminal size for snapshots (cols, rows)."""
    return (SNAPSHOT_TERMINAL_COLS, SNAPSHOT_TERMINAL_ROWS)


def pytest_collection_modifyitems(items: list[pytest.Item]) -> None:
    """Automatically group snapshot tests on the same xdist worker.

    When running with `--dist=loadgroup`, all tests in the `tests/snapshots/`
    directory will be assigned to the same worker. This ensures:
    - Consistent snapshot file access (no race conditions)
    - Proper unused snapshot detection when using --snapshot-update

    Usage:
        pytest tests/ --dist=loadgroup -n auto
    """
    for item in items:
        # Check if the test is in the snapshots directory
        if "tests/snapshots" in str(item.fspath) or "tests\\snapshots" in str(item.fspath):
            # Add xdist_group marker to group all snapshot tests together
            item.add_marker(pytest.mark.xdist_group(name="snapshots"))
